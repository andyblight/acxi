#!/usr/bin/perl
#########################################################################
# acxi - audio conversion program
#########################################################################
# fork to acxi:
# Copyright (c) 2010-2018 - Harald Hope - smxi.org 
# home page: https://github.com/smxi/acxi
# forum support: http://techpatterns.com/forums/about1491.html
# download url: http://smxi.org/acxi
#
# Based on flac2ogg.pl
# Copyright (c) 2004 - Jason L. Buberel - jason@buberel.org
# Copyright (c) 2007 - Evan Boggs - etboggs@indiana.edu
# home page: http://www.buberel.org/linux/batch-flac-to-ogg-converter.php
#
# Modified: 2018-12-05 - Cleaned up code, added use version
# Modified: 2011-07-26 - Harald Hope - Added patch for $ in file names; 
#   changed verbosity levels to fit future 3 release, got rid of 
#   $B_SILENT and $B_QUIET
# Modified: 2011-03-23 - Odd Eivind Ebbesen - www.oddware.net - 
#   <oddebb at gmail dot com>
#   Added functionality for Flac conversion to MP3, preserving tags.
#########################################################################
# This program is free software; you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation; either version 3 of the License, or 
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but 
# WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
# General Public License for more details.
#
# Get the full text of the GPL here: http://www.gnu.org/licenses/gpl.txt
#########################################################################
#########################################################################
# Given a source directory tree of original data files (flac, wav, etc), 
# this program will recreate (or add to) a new directory tree of Ogg 
# files by recursively encoding only new source files to destination types.
# The source and destination directories can be hard-coded using the 
# $DIR_SOURCE and $DIR_DESTINATION variables or passed on the 
# command line.  
#
# If you are piping the output to a log file it would also be good to 
# modify line 92 so that the encoder command is silent (this is done 
# using -Q or --quiet) - oggenc only.  
#
# User config file at $HOME/.acxi.conf or global /etc/acxi.conf, set 
# like this:
# DEST_DIR_PREFIX=/home/me/music/flac
#########################################################################
### NO USER CHANGES IN THIS SECTION ###
use strict;
use warnings;
# use diagnostics;
use 5.008;
use Getopt::Long qw(GetOptions);
use File::stat;

## SELF INFO
my $SELF_NAME = 'acxi';
my $SELF_VERSION = '3.0.0';
my $SELF_DATE = '2018-12-05';

## GLOBALS
my ($B_DEST_CHANGED,$B_FORCE,$B_QUIET);
my $PRINT_LINE_HEAVY;
my $PRINT_LINE_LARGE;
my $PRINT_LINE_SMALL;
my $SILENT_ARG_FO;
my $SILENT_ARG_LAME;
my $USER_TYPES;

## CONSTANTS
my $LINE_HEAVY = "===========================================================================\n";
my $LINE_SMALL = "-----------------------------------------------------------------\n";
my $LINE_LARGE = "---------------------------------------------------------------------------\n";
### END GLOBALS/USE SECTION ###


### USER MODIFIABLE VALUES ###
#
# These can also be set in $HOME/.acxi.conf or $HOME/.config/acxi.conf 
# or /etc/acxi.conf if you prefer
# Anything in configs or in this section will be overridden if you use
# an option.
# Do not use the $ or @ preceding the variable name, or the semicolon 
# or " quote marks in the config file. Use this syntax for config files:
# DIR_PREFIX_SOURCE=/home/fred/music/flac
# DEST_DIR_PREFIX=/home/fred/music/ogg
# Application Commands:
my $COMMAND_OGG = '/usr/bin/oggenc';
my $COMMAND_FLAC = '/usr/bin/flac'; 
my $COMMAND_LAME = '/usr/bin/lame';
# metaflac is required ONLY for flac to mp3, to copy over the ID3 tags
# If you are not going to make MP3s, only OGG files for output, you do 
# not need this.
my $COMMAND_METAFLAC = '/usr/bin/metaflac';

## ASSIGN MUSIC SOURCE/DESTINATION DIRECTORY PATHS
##  $DIR_SOURCE is the original, working, like flac, wav, etc
##  $DIR_DESTINATION is the processed, ie, ogg, mp3
##  CHANGE TO FIT YOUR SYSTEM - do not end in /
my $DIR_SOURCE = '/path/to/source/directory';
my $DIR_DESTINATION = '/path/to/your/output/directory';
# Change if you want these to default to different things
my $QUALITY = 7;
# The following are NOT case sensitive,ie flac/FLAC, txt/TXT will be 
# found
my $INPUT_TYPE = 'flac';
my $OUTPUT_TYPE = 'ogg';
## NOTE: if you want to override @COPY_TYPES in your config files, you
# must use this syntax in your config file:
# USER_TYPES=doc,docx,bmp,jpg,jpeg
# Add or remove types to copy over to ogg directories, do not include
# the input/output types, only extra data types like txt.
# If you want no copying done, simply change this to:
# @COPY_TYPES = ();
# Or if you want to remove or add an extension, do (NO DOTS):
my @COPY_TYPES = qw(bmp doc docx gif jpg jpeg odt pdf png tif txt);
#
# You can turn these to always on either here or in config file by setting to 
# desired verbosity level here directly. 
# 0 = quiet/silent - no output at all; 
# 1 = default - single line per operation. This is the default, so you don't need 
#     to change it.
# 2 = verbose - but without the actual conversion data from codecs
# 3 = debug -  all available information.
# or in config file (note no $, ;, and no quotes): LOG_LEVEL=2
my $LOG_LEVEL = 1;
### END USER MODIFIABLE VARIABLES ###

### MAIN - FUNCTIONS ###
sub error_handler {
	my ($error,$message) = @_;
	my ($errorNo,$errorText) = (0,'');
	if ($error eq 'unsupported-type'){$errorNo = 2;}
	elsif ($error eq 'dest-dir'){$errorNo = 1;}
	elsif ($error eq 'missing-app'){$errorNo = 3;}
	elsif ($error eq 'quality-invalid'){$errorNo = 4;}
	elsif ($error eq 'bad-level'){$errorNo = 5;}
	print "\nError $errorNo - Exiting.$message";
	exit $errorNo;
}

### SET DATA ###
sub set_user_types {
	# if --copy/-c is set, then use that data instead of default copy types
	if ( $USER_TYPES ){
		@COPY_TYPES = split( /,\s*/, $USER_TYPES );
	}
}
sub set_display_output_data {
	if ( $LOG_LEVEL < 3 ) {
		if ( $OUTPUT_TYPE eq 'mp3' ) {
			$SILENT_ARG_FO = '--silent'; # flac output 
			$SILENT_ARG_LAME = '--silent'; # lame output
		}
		elsif ( $OUTPUT_TYPE eq 'ogg' ) {
			$SILENT_ARG_FO = '--quiet'; # for oggenc output
		}
	}
	if ( $LOG_LEVEL < 2 ) {
		$PRINT_LINE_HEAVY = '';
		$PRINT_LINE_LARGE = '';
		$PRINT_LINE_SMALL = '';
	}
	else {
		$PRINT_LINE_HEAVY = 'print $LINE_HEAVY';
		$PRINT_LINE_LARGE = 'print $LINE_LARGE';
		$PRINT_LINE_SMALL = 'print $LINE_SMALL';
	}
}

### VALIDATIONS ###
sub validate_in_out_types {
	my ($bTypeUnsupported, $errorMessage) = (0,'');
	if ( $LOG_LEVEL > 0 ) {
		eval $PRINT_LINE_LARGE;
		print "Checking input and output types... ";
	}
	if ( $INPUT_TYPE !~ m/^(flac|wav|raw)$/ ){
		$bTypeUnsupported = 1;
		$errorMessage .= "\n\tThe input type you entered is not supported: $INPUT_TYPE\n";
	}
	if ( $OUTPUT_TYPE !~ m/^(ogg|mp3)$/ ){
		$bTypeUnsupported = 1;
		$errorMessage .= "\n\tThe output type you entered is not supported: $OUTPUT_TYPE\n";
		if ( $OUTPUT_TYPE eq 'mp3' && $INPUT_TYPE ne 'flac' ){
			$bTypeUnsupported = 1;
			$errorMessage .= "\n\tThe output type $OUTPUT_TYPE you entered currently only supports input type: flac\n";
		}
	}
	if ( $bTypeUnsupported ){
		error_handler('unsupported-type',$errorMessage);
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print "Valid: $INPUT_TYPE(in) $OUTPUT_TYPE(out)\n";
	}
}
sub validate_start_text {
	if ( $LOG_LEVEL > 0 ) {
		eval $PRINT_LINE_HEAVY;
		print "Checking script data for errors...\n";
	}
}
sub validate_src_dest_directories {
	my ($bMissingDir, $missingDirs);
	if ( $LOG_LEVEL > 0 ) {
		eval $PRINT_LINE_LARGE;
		print "Checking source / destination directories... ";
	}
	if ( ! -d "$DIR_SOURCE" ){
		$bMissingDir = 1;
		$missingDirs = "\n\tSource Directory: $DIR_SOURCE";
	}
	if ( ! -d "$DIR_DESTINATION" ){
		$bMissingDir = 1;
		$missingDirs = "$missingDirs\n\tDestination Directory: $DIR_DESTINATION";
	}
	if ( $bMissingDir ) {
		my $errorMessage = "The paths for the following required directories do not exist on your system:";
		$errorMessage .= "$missingDirs";
		$errorMessage .= "\nUnable to continue. Please check the directory paths you provided.\n\n";
		error_handler('dest-dir',$errorMessage);
	} 
	elsif ( $LOG_LEVEL > 0 ) {
		print "Directories: exist\n";
	}
}
sub validate_application_paths {
	my ($bMissingApp, $errorMessage, $appPaths) = (0,'',''); 
	if ( $LOG_LEVEL > 0 ) {
		print "Checking audio conversion tool path... ";
	}
	if ( $OUTPUT_TYPE eq 'ogg' ) {
		$appPaths .= "$COMMAND_OGG ";
		if ( ! -x "$COMMAND_OGG" ) {
			$bMissingApp = 1;
			$errorMessage = "\n\tEncoding application not available: $COMMAND_OGG\n";
		}
	}
	if ( $OUTPUT_TYPE eq 'mp3' ) {
		$appPaths .= "$COMMAND_LAME ";
		if ( ! -x "$COMMAND_LAME" ) {
			$bMissingApp = 1;
			$errorMessage .= "\n\tEncoding application not available: $COMMAND_LAME\n";
		}
	}
	if ( $OUTPUT_TYPE eq 'mp3' && $INPUT_TYPE eq 'flac' ) {
		$appPaths .= "$COMMAND_FLAC ";
		if ( ! -x "$COMMAND_FLAC" ) {
			$bMissingApp = 1;
			$errorMessage .= "\n\tInput processor $COMMAND_FLAC needed by lame not available.\n";
		}
		$appPaths .= "$COMMAND_METAFLAC ";
		# Added: Odd @2011-03-23 01:55:28
		if ( ! -x "$COMMAND_METAFLAC" ) {
			$bMissingApp = 1;
			$errorMessage .= "\n\t$COMMAND_METAFLAC not found. Required to copy ID3 tags from Flac to MP3.\n";
		}
	}
	elsif ( $OUTPUT_TYPE eq 'mp3' && $INPUT_TYPE ne 'flac' ) {
		$bMissingApp = 1;
		$errorMessage .= "\n\t$COMMAND_LAME currently only supports flac as input.\n";
	}
	if ( $bMissingApp ) {
		error_handler('missing-app',$errorMessage);
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print "Available: $appPaths\n";
	}
}
sub validate_quality{
	my ($bBadQuality, $errorMessage);
	if ( $LOG_LEVEL > 0 ) {
		print "Checking quality support for $OUTPUT_TYPE... ";
	}
	if ( $OUTPUT_TYPE eq 'ogg' && $QUALITY !~ m/^([1-9]|10)$/ ) {
		$bBadQuality = 1;
		$errorMessage = "$errorMessage\n\t$OUTPUT_TYPE only supports 1-10 quality. You entered: $QUALITY\n";
	}
	elsif ( $OUTPUT_TYPE eq 'mp3' && $QUALITY !~ m/^([0-9])$/ ) {
		$bBadQuality = 1;
		$errorMessage = "$errorMessage\n\t$OUTPUT_TYPE only supports 0-9 quality. You entered: $QUALITY\n";
	}
	if ( $bBadQuality ) {
		error_handler('quality-invalid',$errorMessage);
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print "Supported: $QUALITY\n";
	}
}
sub validate_log_level {
	my ($bBadLevel, $errorMessage);
	if ( $LOG_LEVEL > 0 ) {
		print "Checking log/screen output level... ";
	}
	if ( $LOG_LEVEL !~ m/^([0-3])$/ ) {
		$bBadLevel = 1;
		$errorMessage = "$errorMessage\n\tLOG_LEVEL only supports 0-3. You used: $LOG_LEVEL\n";
	}
	if ( $bBadLevel ) {
		error_handler('bad-level',$errorMessage);
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print "Supported: $LOG_LEVEL\n";
	}
}

### SYNC MUSIC DIRECTORIES ###
sub sync_music_collections {
	my ($extension,@extensions,@extensionFiles);
	# set the @COPY_TYPES if required by -c/--copy override
	set_user_types();
	@extensions = (@COPY_TYPES,$INPUT_TYPE);
	eval $PRINT_LINE_HEAVY;
	if ( $LOG_LEVEL > 1 ) {
		print "Syncing $DIR_DESTINATION (destination) with\n";
		print "        $DIR_SOURCE (source)...\n";
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print "Starting sync of $DIR_DESTINATION with $DIR_SOURCE...\n";
	}
	sync_collection_directories();
	foreach $extension (@extensions) {
		@extensionFiles = qx(cd "$DIR_SOURCE" && find . -type f -iname "*.$extension" -print);
		eval $PRINT_LINE_LARGE;
		if ( $LOG_LEVEL > 1 ) {
			print "PROCESSING DATA TYPE: $extension\n";
		}
		elsif ( $LOG_LEVEL > 0 ) {
			print "\nProcessing $extension data type...  ";
		}
		sync_collection_files($extension,@extensionFiles);
	}
}
# Recreate the directory hierarchy.
sub sync_collection_directories {
	my ($bDirCreated,$dir,$result );
	my @dirs = qx(cd "$DIR_SOURCE" && find . -type d -print);
	
	eval $PRINT_LINE_LARGE;
	if ( $LOG_LEVEL > 1 ) {
		print "Checking to see if script needs to create new destination directories...\n";
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print "Update destination directories... ";
	}
	foreach $dir (@dirs) {
		$dir =~ s/\n$//;
		$dir =~ s/^\.\///;
		# check to see if the destination dir already exists
		if ( !(stat ("$DIR_DESTINATION/$dir")) ) {
			# stat failed so create the directory
			eval $PRINT_LINE_SMALL;
			if ( $LOG_LEVEL > 1 ) {
				print "CREATING NEW DIRECTORY:\n\t$DIR_DESTINATION/$dir\n";
			}
			elsif ( $LOG_LEVEL > 0 ) {
				print "\nCreating new directory: $dir";
			}
			$dir =~ s/\`/\'/g;
			$result = qx(cd "$DIR_DESTINATION" && mkdir -p "$dir");
			$bDirCreated = 1;
			$B_DEST_CHANGED = 1;
		}
	}
	if ( ! $bDirCreated ){
		if ( $LOG_LEVEL > 1 ) {
			print "No new directories required. Continuing...\n";
		}
		elsif ( $LOG_LEVEL > 0 ) {
			print "None Required.";
		}
	}
}
sub sync_collection_files {
	my ($extension,@files) = @_;
	my ($bFileCreated,$cmd,$result);
	my ($file, $destinationFile,$inFile, $outFile) = ('','','','');
	my ($srcInfo, $srcModTime, $destInfo, $destModTime ) = ('','','','');
	foreach $file (@files) {
		$file =~ s/\n$//;
		$file =~ s/^\.\///;
		#print "F: $DIR_DESTINATION/$file\n";
		# Figure out what the destination file would be...
		$destinationFile = $file;
		if ( $extension eq $INPUT_TYPE ){
			$destinationFile =~ s/\.$INPUT_TYPE$/\.$OUTPUT_TYPE/i;
		}
		#print "D: $destinationFile\n";
		# Now stat the destinationFile, and see if it's date is more recent
		# than that of the original file. If so, we re-encode.
		# We also re-encode if the user supplied --force
		$srcInfo = stat ("$DIR_SOURCE/$file");
		$srcModTime = $srcInfo->mtime;
		$destInfo = stat ("$DIR_DESTINATION/$destinationFile");
		if ( $destInfo ) {
			$destModTime = $destInfo->mtime;
			# print "DEST_MOD: $destModTime :: SRC_MOD: $srcModTime :: FORCE: $force\n"; 
# 		} else {
# 			print "NOT EXISTS: $destinationFile \n"; 
# 			print "P1: $file ==> \n\t$destinationFile\n"; 
		}
		# If the destination file does not exist, or the user specified force,
		# or the srcfile is more recent then the dest file, we encode.
		if ( !$destInfo || $B_FORCE || ( $srcModTime > $destModTime) ) {
			$file =~ s/\`/\'/g;
			$file =~ s/\$/\\\$/g;
			$destinationFile =~ s/\$/\\\$/g; 
			$inFile = "$DIR_SOURCE/$file" . "c";
			chop ($inFile);
			$outFile = "$DIR_DESTINATION/$destinationFile" . "g";
			chop ($outFile);
			eval $PRINT_LINE_SMALL;
			if ( $extension eq $INPUT_TYPE ){
				if ( $LOG_LEVEL > 1 ) {
					print "ENCODE: $file ==> \n";
					print "        $destinationFile\n"; 
				}
				elsif ( $LOG_LEVEL > 0 ) {
					# add line break only when file exists
					print "\nEncoding $file to $OUTPUT_TYPE...";
				}
				$inFile =~ s/\0//g; 
				$outFile =~ s/\0//g;
				if ( $OUTPUT_TYPE eq 'ogg' ){
					$result = qx($COMMAND_OGG $SILENT_ARG_FO -q $QUALITY -o "$outFile" "$inFile");
				}
				elsif ( $OUTPUT_TYPE eq 'mp3' ){
					# Modified: Odd @2011-03-23 01:51:26 - Include ID3 copying
					$cmd = flac2mp3_cmd( $COMMAND_FLAC, "$inFile", $COMMAND_LAME, $QUALITY, "$outFile" );
					$result = qx($cmd);
				}
			} 
			else {
				if ( $LOG_LEVEL > 1 ) {
					print "COPY: $file ==> \n";
					print "      $outFile\n"; 
				}
				elsif ( $LOG_LEVEL > 0 ) {
					print "\nCopying $file...";
				}
				$inFile =~ s/\0//g; 
				$outFile =~ s/\0//g;
				$result = qx(cp -f "$inFile" "$outFile");
			}
			$bFileCreated = 'true';
			$B_DEST_CHANGED = 'true';
		} 
	}
	if ( ! $bFileCreated ){
		if ( $LOG_LEVEL > 1 ) {
			print "No files to process of type: $extension\n";
		}
		elsif ( $LOG_LEVEL > 0 ) {
			print "none found.";
		}
	}
}

# Added: Odd @2011-03-23 01:52:17
# For this function to work reliably, it should be passed tag queries in the order of:
# artist, album, title, genre, date, tracknumber
sub get_flac_tags {
	my ($ifile, @tags) = @_;
	my $cmd = "$COMMAND_METAFLAC \"$ifile\" --show-tag=\"$tags[0]\"";
	$cmd .= " --show-tag=\"$tags[1]\" --show-tag=\"$tags[2]\" --show-tag=\"$tags[3]\"";
	$cmd .= " --show-tag=\"$tags[4]\" --show-tag=\"$tags[5]\"";
	my @origtags = qx($cmd);
	foreach (@origtags) {
		$_ =~ s/.*=//g;
	}
	return @origtags;
}

# Added: Odd @2011-03-23 01:52:31
sub flac2mp3_cmd {
	my ($flac, $ifile, $lame, $qual, $ofile) = @_;
	my @tags = get_flac_tags("$ifile", "ARTIST", "ALBUM", "TITLE", "GENRE", "DATE", "TRACKNUMBER");
	chomp(@tags);
	my $lame_params = "--ta \"$tags[0]\" --tl \"$tags[1]\" --tt \"$tags[2]\" --tg";
	$lame_params .= " \"$tags[3]\" --ty \"$tags[4]\" --tn \"$tags[5]\" - \"$ofile\"";
	my $cmd = "$flac $SILENT_ARG_FO -d -c \"$ifile\" | ";
	$cmd .= "$lame $SILENT_ARG_LAME -h -V $qual $lame_params";
	return $cmd;
}
sub completion_message {
	eval $PRINT_LINE_HEAVY;
	if ( $B_DEST_CHANGED ) {
		if ( $LOG_LEVEL > 1 ) {
			print "All done updating. Enjoy your music!\n";
		}
		elsif ( $LOG_LEVEL > 0 ) {
			print "\nUpdating completed. Enjoy your music!\n";
		}
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print "\nThere was nothing to update today in your collection.\n";
	}
	exit 0;
}

### PRINT HELP/VERSION ###
sub print_help {
	# so it shows the user config data if present
	set_config_data(); 
	# but this should override the config data so follows
	set_user_types();
	my $output = "$SELF_NAME v: $SELF_VERSION :: Supported Options:\n";
	$output .= "Examples: $SELF_NAME -q 8 --destination /music/main/ogg\n";
	$output .= "$SELF_NAME --input wav --output ogg\n";
	$output .= "$SELF_NAME --copy doc,docx,bmp\n";
	$output .= $LINE_SMALL;
	$output .= "--copy -c         List of alternate data types to copy to Output type\n";
	$output .= "                  directories. Must be comma separated, no spaces, \n";
	$output .= "                  see sample above. Your current copy types are:\n";
	$output .= "                  @COPY_TYPES\n";
	$output .= "--debug           Full screen output, including full verbosity of \n";
	$output .= "                  flac/oggenc/lameconversion process for MP3 or OGG output.\n";
	$output .= "--default         Single line per operation screen output, default value for \n";
	$output .= "                  $SELF_NAME.\n";
	$output .= "--destination -d  Path to the directory where you want the processed\n";
	$output .= "                  (eg, ogg) files to go.\n";
	$output .= "                  Your current default is: $DIR_DESTINATION\n";
	$output .= "--force -f        Overwrite the ogg/jpg/txt files, even if they already exist.\n";
	$output .= "--help -h         This help menu.\n";
	$output .= "--input -i        Input type: supported - flac, wav, raw. mp3 only supports\n";
	$output .= "                  flac input. Your current default is: $INPUT_TYPE\n";
	$output .= "--output -o       Output type: supported - ogg, mp3\n";
	$output .= "                  Your current default is: $OUTPUT_TYPE\n";
	$output .= "--quality n -q n  For ogg: n can be 1-10. 10 is the largest file/\n";
	$output .= "                  highest quality.\n";                
	$output .= "                  For mp3: n can be 0-9 (variable bit rate), 0 is largest file/\n";
	$output .= "                  highest quality. \n";
	$output .= "                  Your current default is: $QUALITY\n";
	$output .= "--quiet --silent  Turns off all screen output, except for error messages.\n";
	$output .= "--source -s       Path to the top-most directory containing your source files\n";
	$output .= "                  (eg, flac). Your current default is: $DIR_SOURCE\n";
	$output .= "--verbose         Without full verbosity of debug, no flac/oggenc/lame for MP3\n";
	$output .= "                  or OGG conversion process screen output, but more verbose than\n";
	$output .= "                  default.\n";
	$output .= "--version -v      Show $SELF_NAME version.\n\n";
	$output .= $LINE_SMALL;
	$output .= "User Configs (checked in this order):\n";
	$output .= "/etc/$SELF_NAME.conf\n";
	$output .= "\$HOME/.$SELF_NAME.conf\n";
	$output .= "\$HOME/.config/$SELF_NAME.conf\n";
	$output .= "Requires this syntax (any user modifiable variable can be used)\n";
	$output .= "DIR_PREFIX_SOURCE=/home/me/music/flac\n";
	$output .= "Do not use the \$ or \", \' in the config data\n";
	$output .= "\n";
	print $output;
	exit 0;
}
sub print_version {
	my $output = "You are using $SELF_NAME version: $SELF_VERSION\n";
	$output .= "Script date: $SELF_DATE\n";
	print $output;
	exit 0;
}

### SET PROGRAM DATA ###
sub set_config_data {
	my (@configFiles, $file);
	# set list of supported config files
	@configFiles = ("/etc/$SELF_NAME.conf","$ENV{HOME}/.$SELF_NAME.conf",
	"$ENV{HOME}/.config/$SELF_NAME.conf");
	foreach $file (@configFiles) {
		next unless -r $file && open (my $fh,'<',$file);
		while (<$fh>) {
			chomp;                  # no newline
			s/#.*//;                # no comments
			s/^\s+//;               # no leading white
			s/\s+$//;               # no trailing white
			next unless length;     # anything left?
			my ($var, $value) = split(/\s*=\s*/, $_, 2);
			if (defined $var && defined $value){
				assign_config_value($var, $value);
			}
		}
	}
}
sub assign_config_value {
	my ($var,$value) = @_;
	if ($var eq 'COMMAND_OGG'){$COMMAND_OGG = $value;}
	elsif ($var eq 'COMMAND_FLAC'){$COMMAND_FLAC = $value;}
	elsif ($var eq 'COMMAND_LAME'){$COMMAND_LAME = $value;}
	elsif ($var eq 'COMMAND_METAFLAC'){$COMMAND_METAFLAC = $value;}
	elsif ($var eq 'DIR_SOURCE' || $var eq 'DIR_PREFIX_SOURCE'){$DIR_SOURCE = $value;}
	elsif ($var eq 'DIR_DESTINATION' || $var eq 'DIR_PREFIX_DEST'){$DIR_DESTINATION = $value;}
	elsif ($var eq 'INPUT_TYPE'){$INPUT_TYPE = $value;}
	elsif ($var eq 'LOG_LEVEL'){$LOG_LEVEL = $value;}
	elsif ($var eq 'OUTPUT_TYPE'){$OUTPUT_TYPE = $value;}
	elsif ($var eq 'QUALITY'){$QUALITY = $value;}
	elsif ($var eq 'USER_TYPES'){$USER_TYPES = $value;}
}
# get defaults from user config files if present
set_config_data();
# Get Options and set values, this overrides defaults 
# from top globals and config files
GetOptions (
	"c|copy:s" => sub { 
		my ($opt,$arg) = @_;
		$USER_TYPES = $arg;},
	"debug" => sub { 
		$LOG_LEVEL = 3 },
	"default" => sub { 
		$LOG_LEVEL = 1 },
	"d|destination:s" => sub { 
		my ($opt,$arg) = @_;
		$DIR_DESTINATION = $arg },
	"f|force" => sub { 
		$B_FORCE = 1 },
	"h|help|?" => sub { 
		print_help();},
	"i|input:s" => sub { 
		my ($opt,$arg) = @_;
		$INPUT_TYPE = $arg },
	"o|output:s" => sub {
		my ($opt,$arg) = @_;
		$OUTPUT_TYPE = $arg;},
	"q|quality:s" => sub { 
		my ($opt,$arg) = @_;
		$QUALITY = $arg }, # validate later
	"s|source:s" => sub { 
		my ($opt,$arg) = @_;
		$DIR_SOURCE = $arg;},
	"quiet|silent" => sub { 
		$B_QUIET = 1; 
		$LOG_LEVEL = 0 },
	"verbose" => sub { 
		$LOG_LEVEL = 2 },
	"v|version" => sub { 
		print_version(); }
);

### EXECUTE / PROCESS MUSIC ###
set_display_output_data();
validate_start_text();
validate_log_level();
validate_src_dest_directories();
validate_in_out_types();
validate_quality();
validate_application_paths();
sync_music_collections();
completion_message();

###**EOF**###
